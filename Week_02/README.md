# HashMap 小结

### hash 方法

```Java
(h = key.hashCode()) ^ (h >>> 16)
```

算法将32位的hashcode与除2的16次方的数进行异或，确保低位的随机性。

```Java
i = (n - 1) & hash
```

真正的下标需要将数组长度-1与hash值进行与运算。

## put 方法

实际是putVal

桶中没元素就扩容或者放节点；桶中有元素就比较key是否相同，相同就覆盖；不同就判断桶中节点是否为树节点，是树节点就红黑树添加，否就遍历，如果发现相同key值，则替换，否则是到链表尾部尾节点相加，假如节点数量达到阈值，就转化成红黑树。

若是更改了以前有的节点，那返回原本的value，若是新增返回null。

#### putIfAbsent方法

即如果没有才进行put方法。

### get方法

实际是getNode

若数组key相同就返回对应节点；若桶中不止一个节点，是树节点就红黑树查找，否则循环在链表中查找；若找不到返回空值。

### containsKey方法

实际是getNode方法，只要不为空就返回true

### containsValue

双重循环，外层遍历散列表的数组，在每个数组内遍历所有节点。

### clear方法

遍历散列表数组，将散列表的头指针清空，剩下的GC会自动处理。（是否有魔改空间hhh）

### resize方法

旧散列表超过最大限度（默认2的30次方）就不扩容，没扩容就翻倍。

扩容时， 遍历旧的散列表数组，假如是单个节点，就将其hash值与新长度与运算；如果是红黑树就用红黑树的方法；如果是链表就循环，将原索引分为上下两部分（跟原索引对应长度和多出来的长度），最后放入散列表的位置也与之相关。

### remove方法

也是按照单节点，树，链表查找，查找到后将其指向下个节点，也就是将其删除。



# HashSet的方法们

### HashSet本质就是HashMap

### add 方法

等同HashMap.put，只是value是PRESENT，一个空Object。若放进去的位空，即原本没有旧元素，则true，否则false

### remove方法

等同map.remove

### contains

等同于map.containsKey

学习笔记